// config/db.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    // `await` akan menunggu koneksi selesai, lalu hasilnya dimasukkan ke `conn`.
    const conn = await mongoose.connect(process.env.MONGO_URI);

    // Jika baris di atas berhasil, kode ini akan berjalan.
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    // Jika `await` gagal, akan langsung loncat ke blok `catch` ini.
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

// controllers/authController.js
const User = require('../models/userModel');
const jwt = require('jsonwebtoken');

// Fungsi untuk generate token
const generateToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: '30d',
  });
};

// @desc    Register a new user
// @route   POST /api/auth/register
// @access  Public
const registerUser = async (req, res) => {
  const { nama, password, no_hp, alamat } = req.body;

  if (!nama || !password || !no_hp) {
    return res.status(400).json({ message: 'nama, no_hp, dan password wajib diisi' });
  }

  try {
    const userExists = await User.findOne({ no_hp });

    if (userExists) {
      return res.status(400).json({ message: 'No HP sudah terdaftar' });
    }

    const user = await User.create({
      nama,
      password,
      no_hp,
      alamat,
    });

    if (user) {
      res.status(201).json({
        _id: user._id,
        nama: user.nama,
        no_hp: user.no_hp,
        role: user.role,
        token: generateToken(user._id),
      });
    } else {
      res.status(400).json({ message: 'Data user tidak valid' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Server Error' });
  }
};

// @desc    Auth user & get token (Login)
// @route   POST /api/auth/login
// @access  Public
const loginUser = async (req, res) => {
  const { no_hp, password } = req.body;

  if (!no_hp || !password) {
    return res.status(400).json({ message: 'no_hp dan password wajib diisi' });
  }

  try {
    const user = await User.findOne({ no_hp });
    if (!user) {
      return res.status(401).json({ message: 'No HP atau password salah' });
    }
    const isMatch = await user.matchPassword(password);
    if (!isMatch) {
      return res.status(401).json({ message: 'No HP atau password salah' });
    }
    res.json({
      _id: user._id,
      nama: user.nama,
      no_hp: user.no_hp,
      role: user.role,
      token: generateToken(user._id),
    });
  } catch (error) {
    res.status(500).json({ message: 'Server Error' });
  }
};

module.exports = { registerUser, loginUser };


const Booking = require('../models/bookingModel');
const Lapangan = require('../models/lapanganModel');
const Jadwal = require('../models/jadwalModel');

/**
 * @desc    Membuat booking baru (Hanya User)
 * @route   POST /api/bookings
 * @access  Private
 */
const createBooking = async (req, res) => {
  const { lapanganId, tanggal_booking, jam_mulai, jam_selesai } = req.body;

  try {
    // 1. Validasi Input Dasar
    if (!lapanganId || !tanggal_booking || !jam_mulai || !jam_selesai) {
      return res.status(400).json({ message: 'Semua field wajib diisi' });
    }
    if (jam_mulai >= jam_selesai) {
      return res.status(400).json({ message: 'Jam selesai harus setelah jam mulai' });
    }

    // 2. Cek ketersediaan lapangan
    const lapangan = await Lapangan.findById(lapanganId);
    if (!lapangan || lapangan.status !== 'tersedia') {
      return res.status(404).json({ message: 'Lapangan tidak ditemukan atau sedang tidak tersedia' });
    }

    // 3. Cek jadwal yang bentrok
    const tanggal = new Date(new Date(tanggal_booking).setHours(0, 0, 0, 0));
    const jadwal = await Jadwal.findOne({ lapangan: lapanganId, tanggal });

    if (jadwal) {
      const isBentrok = jadwal.slot_terisi.some(
        slot => jam_mulai < slot.jam_selesai && jam_selesai > slot.jam_mulai
      );
      if (isBentrok) {
        return res.status(400).json({ message: 'Jadwal pada jam tersebut sudah terisi (bentrok)' });
      }
    }

    // 4. Hitung durasi dan total harga
    const durasi = jam_selesai - jam_mulai;
    const total_harga = durasi * lapangan.harga_per_jam;

    // 5. Buat kode booking unik
    const kode_booking = `BKG-${Date.now()}`;

    // 6. Buat dokumen booking baru
    const booking = await Booking.create({
      kode_booking,
      user: req.user._id,
      lapangan: lapanganId,
      tanggal_booking: tanggal,
      jam_mulai,
      jam_selesai,
      durasi,
      total_harga,
    });

    // 7. Update atau buat dokumen jadwal baru
    if (jadwal) {
      jadwal.slot_terisi.push({ jam_mulai, jam_selesai, booking: booking._id });
      await jadwal.save();
    } else {
      await Jadwal.create({
        lapangan: lapanganId,
        tanggal,
        slot_terisi: [{ jam_mulai, jam_selesai, booking: booking._id }],
      });
    }

    res.status(201).json(booking);
  } catch (error) {
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

/**
 * @desc    Melihat riwayat booking (Hanya User)
 * @route   GET /api/bookings/my-history
 * @access  Private
 */
const getMyBookings = async (req, res) => {
    try {
        const bookings = await Booking.find({ user: req.user._id })
          .populate('lapangan', 'nama')
          .sort({ createdAt: -1 });
        res.json(bookings);
    } catch (error) {
        res.status(500).json({ message: 'Server Error: ' + error.message });
    }
}

/**
 * @desc    Melihat daftar semua bookingan (Hanya Admin)
 * @route   GET /api/bookings/all
 * @access  Private/Admin
 */
const getAllBookings = async (req, res) => {
    try {
        const bookings = await Booking.find({})
          .populate('user', 'nama no_hp')
          .populate('lapangan', 'nama')
          .sort({ createdAt: -1 });
        res.json(bookings);
    } catch (error) {
        res.status(500).json({ message: 'Server Error: ' + error.message });
    }
}

module.exports = { createBooking, getMyBookings, getAllBookings };


const Lapangan = require('../models/lapanganModel');

/**
 * @desc    Membuat lapangan baru (Hanya Admin)
 * @route   POST /api/lapangan
 * @access  Private/Admin
 */
const createLapangan = async (req, res) => {
  const { nama, deskripsi, harga_per_jam, foto, status } = req.body;

  if (!nama || !harga_per_jam) {
    return res.status(400).json({ message: 'Nama dan harga per jam wajib diisi' });
  }

  try {
    const lapangan = new Lapangan({
      nama,
      deskripsi,
      harga_per_jam,
      foto,
      status,
    });

    const createdLapangan = await lapangan.save();
    res.status(201).json(createdLapangan);
  } catch (error) {
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

/**
 * @desc    Mendapatkan semua data lapangan (Untuk User & Admin)
 * @route   GET /api/lapangan
 * @access  Public
 */
const getAllLapangan = async (req, res) => {
  try {
    // User hanya bisa melihat lapangan yang statusnya 'tersedia'
    const query = req.user && req.user.role === 'admin' ? {} : { status: 'tersedia' };
    const lapangan = await Lapangan.find(query);
    res.json(lapangan);
  } catch (error) {
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

/**
 * @desc    Mendapatkan detail satu lapangan by ID (Untuk User & Admin)
 * @route   GET /api/lapangan/:id
 * @access  Public
 */
const getLapanganById = async (req, res) => {
  try {
    const lapangan = await Lapangan.findById(req.params.id);

    if (lapangan) {
      res.json(lapangan);
    } else {
      res.status(404).json({ message: 'Lapangan tidak ditemukan' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

/**
 * @desc    Update data lapangan (Hanya Admin)
 * @route   PUT /api/lapangan/:id
 * @access  Private/Admin
 */
const updateLapangan = async (req, res) => {
  const { nama, deskripsi, harga_per_jam, foto, status } = req.body;

  try {
    const lapangan = await Lapangan.findById(req.params.id);

    if (lapangan) {
      lapangan.nama = nama || lapangan.nama;
      lapangan.deskripsi = deskripsi || lapangan.deskripsi;
      lapangan.harga_per_jam = harga_per_jam || lapangan.harga_per_jam;
      lapangan.foto = foto || lapangan.foto;
      lapangan.status = status || lapangan.status;

      const updatedLapangan = await lapangan.save();
      res.json(updatedLapangan);
    } else {
      res.status(404).json({ message: 'Lapangan tidak ditemukan' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

/**
 * @desc    Menghapus lapangan (Hanya Admin)
 * @route   DELETE /api/lapangan/:id
 * @access  Private/Admin
 */
const deleteLapangan = async (req, res) => {
  try {
    const lapangan = await Lapangan.findById(req.params.id);

    if (lapangan) {
      await lapangan.deleteOne();
      res.json({ message: 'Lapangan berhasil dihapus' });
    } else {
      res.status(404).json({ message: 'Lapangan tidak ditemukan' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};


module.exports = {
  createLapangan,
  getAllLapangan,
  getLapanganById,
  updateLapangan,
  deleteLapangan
};


// middlewares/authMiddleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');

const protect = async (req, res, next) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = await User.findById(decoded.id).select('-password');
      next();
    } catch (error) {
      res.status(401).json({ message: 'Not authorized, token failed' });
    }
  }

  if (!token) {
    res.status(401).json({ message: 'Not authorized, no token' });
  }
};

const admin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Not authorized as an admin' });
  }
};

module.exports = { protect, admin };


const mongoose = require('mongoose');

const bookingSchema = mongoose.Schema(
  {
    kode_booking: {
      type: String,
      required: true,
      unique: true,
    },
    user: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: 'User', // Referensi ke model User
    },
    lapangan: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: 'Lapangan', // Referensi ke model Lapangan
    },
    tanggal_booking: {
      type: Date,
      required: true,
    },
    jam_mulai: {
      type: Number, // Format 24 jam, contoh: 14 untuk jam 2 siang
      required: true,
    },
    jam_selesai: {
      type: Number, // Format 24 jam, contoh: 16 untuk jam 4 sore
      required: true,
    },
    durasi: {
      type: Number, // Dalam jam
      required: true,
    },
    total_harga: {
      type: Number,
      required: true,
    },
    status_pembayaran: {
      type: String,
      required: true,
      enum: ['pending', 'lunas', 'dibatalkan'],
      default: 'pending',
    },
  },
  {
    timestamps: true, // Otomatis menambahkan createdAt dan updatedAt
  }
);

const Booking = mongoose.model('Booking', bookingSchema);

module.exports = Booking;

const mongoose = require('mongoose');

const jadwalSchema = mongoose.Schema(
  {
    lapangan: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: 'Lapangan',
    },
    tanggal: {
      type: Date,
      required: true,
    },
    // Array ini akan menyimpan semua slot yang sudah dibooking pada tanggal tersebut
    slot_terisi: [
      {
        jam_mulai: { type: Number, required: true },
        jam_selesai: { type: Number, required: true },
        booking: { // Menghubungkan slot ini ke ID booking yang bersangkutan
          type: mongoose.Schema.Types.ObjectId,
          required: true,
          ref: 'Booking',
        },
      },
    ],
  },
  {
    timestamps: true,
  }
);

// Membuat index komposit untuk memastikan setiap lapangan hanya punya satu dokumen jadwal per tanggal
jadwalSchema.index({ lapangan: 1, tanggal: 1 }, { unique: true });

const Jadwal = mongoose.model('Jadwal', jadwalSchema);

module.exports = Jadwal;

// models/lapanganModel.js
const mongoose = require('mongoose');

const lapanganSchema = mongoose.Schema(
  {
    nama: { type: String, required: true },
    deskripsi: { type: String },
    harga_per_jam: { type: Number, required: true },
    foto: [{ type: String }],
    status: {
      type: String,
      required: true,
      enum: ['tersedia', 'dalam perbaikan', 'tidak tersedia'],
      default: 'tersedia',
    },
  },
  { timestamps: true }
);

const Lapangan = mongoose.model('Lapangan', lapanganSchema);
module.exports = Lapangan;


// models/userModel.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = mongoose.Schema(
  {
    nama: { type: String, required: true },
      // Removed email field: primary identifier is `no_hp`
    password: { type: String, required: true },
    no_hp: { type: String, required: true, unique: true },
    alamat: { type: String },
    role: { type: String, required: true, enum: ['user', 'admin'], default: 'user' },
  },
  { timestamps: true }
);

// Enkripsi password sebelum disimpan
userSchema.pre('save', async function (next) {
    if (!this.isModified('password')) {
      return next();
    }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

// Method untuk mencocokkan password
userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', userSchema);
module.exports = User;


// routes/authRoutes.js
const express = require('express');
const router = express.Router();
const { registerUser, loginUser } = require('../controllers/authController');

router.post('/register', registerUser);
router.post('/login', loginUser);

module.exports = router;


const express = require('express');
const router = express.Router();
const { createBooking, getMyBookings, getAllBookings } = require('../controllers/bookingController');
const { protect, admin } = require('../middlewares/authMiddleware');

// == RUTE UNTUK USER ==
// POST /api/bookings -> Membuat booking baru
router.post('/', protect, createBooking); 

// GET /api/bookings/my-history -> Melihat riwayat booking user
router.get('/my-history', protect, getMyBookings);

// == RUTE UNTUK ADMIN ==
// GET /api/bookings/all -> Melihat semua bookingan
router.get('/all', protect, admin, getAllBookings);

module.exports = router;

const express = require('express');
const router = express.Router();
const {
  createLapangan,
  getAllLapangan,
  getLapanganById,
  updateLapangan,
  deleteLapangan,
} = require('../controllers/lapanganController');
const { protect, admin } = require('../middlewares/authMiddleware');

// Rute untuk melihat data lapangan (bisa diakses user biasa dan admin)
router.route('/').get(protect, getAllLapangan);
router.route('/:id').get(protect, getLapanganById);

// Rute khusus Admin untuk CUD (Create, Update, Delete)
router.route('/').post(protect, admin, createLapangan);
router.route('/:id').put(protect, admin, updateLapangan);
router.route('/:id').delete(protect, admin, deleteLapangan);

module.exports = router;

const express = require('express');
const dotenv = require('dotenv');
const cors = require('cors');
const connectDB = require('./config/db');

// Import routes
const authRoutes = require('./routes/authRoutes');
const lapanganRoutes = require('./routes/lapanganRoutes');
const bookingsRoutes = require('./routes/bookingRoutes');

// Load env vars
dotenv.config();

// Connect to database
connectDB();

const app = express();

// Body parser
app.use(express.json());

// Enable CORS
app.use(cors());

// Mount routers
app.use('/api/auth', authRoutes);
app.use('/api/lapangan', lapanganRoutes);
app.use('/api/bookings', bookingsRoutes);

const PORT = process.env.PORT || 5000;
const HOST = process.env.HOST || '0.0.0.0';

const displayHost = HOST === '0.0.0.0' ? 'localhost' : HOST;

app.listen(PORT, HOST, () => {
  console.log(`Server running in ${process.env.NODE_ENV || 'development'} mode at http://${displayHost}:${PORT}`);
});

process.on('unhandledRejection', (err, promise) => {
  console.error(`Unhandled Rejection: ${err.message}`);
});

meralda raihan putri cewenya danis

